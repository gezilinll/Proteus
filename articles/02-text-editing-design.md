# 文字编辑系统设计方案

> 本文档调研并设计 Proteus 编辑器的文字编辑和渲染技术方案。

---

## 问题背景

文字编辑是图形编辑器中最复杂的功能之一，需要解决以下核心问题：

1. **所见即所得（WYSIWYG）**：编辑时和最终渲染效果一致
2. **光标和选区**：文字光标、选区高亮、多光标支持
3. **输入法支持**：中文、日文等 IME 输入法的正确处理
4. **富文本支持**：不同字体、大小、颜色、粗体、斜体等
5. **性能**：大段文字的流畅编辑和渲染
6. **跨平台**：不同浏览器和设备的兼容性

---

## 技术方案对比

### 方案 A：DOM 覆盖层（当前方案）

**原理**：编辑时在 Canvas 上方覆盖一个 `<textarea>` 或 `contenteditable` 元素。

```
┌─────────────────────────────┐
│  DOM 编辑层 (textarea)       │ ← 编辑时显示
├─────────────────────────────┤
│  Canvas 渲染层               │ ← 最终渲染
└─────────────────────────────┘
```

**优点**：
- 实现简单，利用浏览器原生能力
- 输入法支持完善（浏览器已处理）
- 复制粘贴、Undo/Redo 等浏览器原生支持

**缺点**：
- ❌ 非所见即所得：编辑位置和渲染位置可能有偏差
- ❌ 样式对齐困难：DOM 和 Canvas 的字体渲染有细微差异
- ❌ 视觉割裂感：切换编辑/预览模式有明显跳跃
- ❌ 富文本支持复杂：需要同步 DOM 和 Canvas 的样式

**适用场景**：简单文字编辑，MVP 阶段

---

### 方案 B：Canvas 原生实现

**原理**：完全在 Canvas 中实现文字编辑，包括光标、选区、输入处理。

```
┌─────────────────────────────┐
│  Canvas                      │
│  ┌───────────────────────┐  │
│  │ Text|                  │  │ ← 光标在 Canvas 中绘制
│  │ Selected text          │  │ ← 选区在 Canvas 中绘制
│  └───────────────────────┘  │
└─────────────────────────────┘
```

**优点**：
- ✅ 完全所见即所得
- ✅ 完全控制渲染效果
- ✅ 无样式同步问题
- ✅ 可实现复杂效果（曲线文字、路径文字等）

**缺点**：
- ❌ 实现极其复杂（需要自己实现光标、选区、输入法）
- ❌ 输入法支持困难（需要隐藏 input + 手动处理 IME 事件）
- ❌ 浏览器兼容性问题（IME 行为不一致）
- ❌ 开发周期长（可能需要 2-4 周）

**技术难点**：
1. 光标位置计算：`ctx.measureText()` 测量每个字符位置
2. 选区绘制：需要计算多行选区的矩形区域
3. 输入法处理：监听 `compositionstart/update/end` 事件
4. 滚动支持：长文本的滚动和虚拟化

**适用场景**：需要完全控制渲染效果，如 Figma

---

### 方案 C：第三方富文本编辑器

**可选库**：

| 库 | 特点 | Stars | 体积 |
|---|---|---|---|
| **Slate.js** | 完全可定制，框架无关内核 | 28k | ~100KB |
| **TipTap** | 基于 ProseMirror，Vue/React 友好 | 24k | ~150KB |
| **Lexical** | Facebook 出品，高性能 | 17k | ~50KB |
| **Quill** | 开箱即用，主题丰富 | 38k | ~40KB |
| **Editor.js** | 块级编辑，类 Notion | 25k | ~100KB |

**优点**：
- ✅ 成熟稳定，bug 少
- ✅ 富文本功能完善
- ✅ 输入法、复制粘贴等已处理

**缺点**：
- ❌ 与 Canvas 集成困难：编辑器渲染 DOM，我们渲染 Canvas
- ❌ 样式同步问题：需要保证 DOM 和 Canvas 渲染一致
- ❌ 额外依赖：增加包体积
- ❌ 定制成本：可能需要深度修改

**适用场景**：需要完善的富文本编辑能力

---

### 方案 D：混合渲染方案（推荐）

**原理**：编辑时使用 DOM（contenteditable），渲染时使用 Canvas，确保两者完全对齐。

```
编辑模式：
┌─────────────────────────────┐
│  DOM 层 (contenteditable)    │ ← 可见，接收输入
├─────────────────────────────┤
│  Canvas 层                   │ ← 隐藏或透明
└─────────────────────────────┘

预览模式：
┌─────────────────────────────┐
│  DOM 层                      │ ← 隐藏
├─────────────────────────────┤
│  Canvas 层                   │ ← 可见，渲染文字
└─────────────────────────────┘
```

**关键技术**：

1. **精确对齐**：
   - 使用相同的字体、行高、padding
   - DOM 元素位置与 Canvas 中文字位置完全一致
   - 编辑时隐藏 Canvas 中的文字，显示 DOM

2. **无缝切换**：
   - 双击进入编辑 → DOM 淡入，Canvas 文字隐藏
   - 失去焦点 → DOM 淡出，Canvas 文字显示
   - 过渡动画使切换更自然

3. **样式同步**：
   - DOM 和 Canvas 使用相同的样式计算
   - 字体度量（font metrics）保持一致

**优点**：
- ✅ 利用浏览器原生编辑能力
- ✅ 输入法支持完善
- ✅ 可以使用 contenteditable 或轻量富文本库
- ✅ Canvas 渲染保持一致性

**缺点**：
- 需要精确对齐 DOM 和 Canvas
- 仍有轻微的模式切换感知

**适用场景**：平衡开发成本和用户体验

---

## 推荐方案

### Phase 1（当前）：优化 DOM 覆盖层方案

**目标**：快速实现基本可用的文字编辑

**改进点**：
1. 编辑时隐藏 Canvas 中的文字元素
2. DOM 编辑框精确对齐元素位置
3. 使用 `contenteditable` 替代 `textarea`（更好的多行支持）
4. 添加淡入淡出过渡效果

**实现周期**：1-2 天

### Phase 2（后续）：混合渲染方案

**目标**：实现接近所见即所得的体验

**改进点**：
1. 实时同步 DOM 编辑器和 Canvas 渲染
2. 支持基础富文本（粗体、斜体、颜色）
3. 考虑引入 Lexical 或 Slate 作为编辑器内核

**实现周期**：1-2 周

### Phase 3（远期）：Canvas 原生方案

**目标**：完全所见即所得，支持高级效果

**改进点**：
1. Canvas 原生光标和选区渲染
2. 输入法完整支持
3. 路径文字、曲线文字等高级效果

**实现周期**：2-4 周

---

## 当前实现改进方案

### 问题分析

当前问题：
1. 编辑框和 Canvas 文字同时显示，视觉混乱
2. 编辑框位置与文字位置有偏差
3. 样式不完全匹配

### 改进方案

```typescript
// 编辑模式：隐藏 Canvas 中的文字
editor.scene.update(elementId, {
  style: { ...style, _editing: true } // 渲染器检测此标记，跳过渲染
});

// DOM 编辑器精确对齐
const editorStyle = {
  position: 'absolute',
  left: `${screenX}px`,
  top: `${screenY}px`,
  width: `${width * zoom}px`,
  minHeight: `${height * zoom}px`,
  
  // 与 Canvas 渲染完全一致的样式
  fontSize: `${fontSize * zoom}px`,
  fontFamily: fontFamily,
  fontWeight: fontWeight,
  lineHeight: 1.2,
  textAlign: textAlign,
  color: fill,
  
  // 透明背景，无边框（所见即所得）
  background: 'transparent',
  border: 'none',
  outline: 'none',
  
  // 光标颜色
  caretColor: '#3b82f6',
};
```

### 渲染器改进

```typescript
// TextRenderer.ts
render(ctx: RenderContext, element: Element): void {
  // 如果正在编辑，跳过渲染
  if (element.style._editing) {
    return;
  }
  
  // 正常渲染逻辑...
}
```

---

## 行业参考

### Figma
- 使用 **Canvas 原生方案**
- 完全所见即所得
- 自己实现了光标、选区、输入法
- 开发周期长，但体验最好

### Miro
- 使用 **DOM 覆盖层方案**
- 编辑时显示 DOM 编辑框
- 样式与 Canvas 渲染接近但不完全一致

### Canva
- 使用 **混合方案**
- 编辑时使用 DOM
- 渲染时使用 Canvas
- 有较好的对齐

### Excalidraw
- 使用 **DOM 覆盖层方案**
- 简单 textarea
- 接受一定的样式差异

---

## 决策建议

考虑到：
1. Proteus 是 AI 原生编辑器，文字编辑不是核心差异点
2. 需要快速迭代验证核心功能
3. 后续可以逐步优化

**建议**：

1. **短期（Phase 1）**：优化当前 DOM 覆盖层方案，实现基本可用
2. **中期（Phase 2）**：实现混合渲染方案，提升体验
3. **长期（Phase 3）**：根据用户反馈决定是否需要 Canvas 原生方案

---

## 下一步行动

1. 修改 `TextRenderer`：支持 `_editing` 标记
2. 修改 `TextEditOverlay`：编辑时隐藏 Canvas 文字
3. 优化样式对齐：确保 DOM 和 Canvas 渲染一致
4. 添加过渡效果：平滑的编辑/预览切换

---

*本文档将随着开发进度持续更新。*

